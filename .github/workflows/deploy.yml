name: Build and Deploy Application

on:
  push:
    branches:
      - main

env:
  REGISTRY_URL: http://registry.registry.svc.cluster.local:5000
  REGISTRY_HOST: registry.registry.svc.cluster.local:5000
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-deploy:
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
          # Use docker-container driver to ensure it respects daemon.json
          driver: docker

      - name: Configure Docker for local HTTP registry
        run: |
          # Configure Docker to use HTTP (not HTTPS) for local registry
          # This is required because the local k3s registry uses HTTP on port 5000
          
          REGISTRY_HOST="${{ env.REGISTRY_HOST }}"
          
          # Try to configure insecure registry in daemon.json (requires sudo)
          if command -v sudo &> /dev/null; then
            # Ensure /etc/docker directory exists
            sudo mkdir -p /etc/docker
            
            if [ -f /etc/docker/daemon.json ]; then
              # Backup first
              sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.bak 2>/dev/null || true
              
              # Use jq if available, otherwise use sed
              if command -v jq &> /dev/null; then
                # Add insecure-registries if not already present
                if ! jq -e '.insecure-registries' /etc/docker/daemon.json > /dev/null 2>&1; then
                  jq '. + {"insecure-registries": ["'$REGISTRY_HOST'"]}' /etc/docker/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null
                elif ! jq -e '.insecure-registries[] | select(. == "'$REGISTRY_HOST'")' /etc/docker/daemon.json > /dev/null 2>&1; then
                  jq '.insecure-registries += ["'$REGISTRY_HOST'"]' /etc/docker/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null
                else
                  echo "Registry $REGISTRY_HOST already configured in insecure-registries"
                fi
              else
                # Simple sed approach - check if registry already exists
                if grep -q "$REGISTRY_HOST" /etc/docker/daemon.json 2>/dev/null; then
                  echo "Registry $REGISTRY_HOST already configured"
                elif ! grep -q "insecure-registries" /etc/docker/daemon.json; then
                  # Add insecure-registries to existing JSON
                  sudo sed -i 's/}/,\n  "insecure-registries": ["'$REGISTRY_HOST'"]\n}/' /etc/docker/daemon.json
                else
                  # Append to existing insecure-registries array
                  sudo sed -i 's/"insecure-registries": \[/"insecure-registries": ["'$REGISTRY_HOST'", /' /etc/docker/daemon.json
                fi
              fi
            else
              # Create new daemon.json with insecure-registries
              echo '{"insecure-registries": ["'$REGISTRY_HOST'"]}' | sudo tee /etc/docker/daemon.json > /dev/null
              echo "Created /etc/docker/daemon.json with insecure-registries configuration"
            fi
            
            # Verify the configuration
            echo "Current Docker daemon.json configuration:"
            sudo cat /etc/docker/daemon.json || echo "Failed to read daemon.json"
            
            # Restart Docker daemon to apply changes
            echo "Restarting Docker daemon..."
            # Stop Docker first
            sudo systemctl stop docker 2>/dev/null || sudo service docker stop 2>/dev/null || true
            sleep 2
            # Start Docker
            sudo systemctl start docker 2>/dev/null || sudo service docker start 2>/dev/null || echo "Docker start failed"
            # Also try full restart
            sudo systemctl restart docker 2>/dev/null || sudo service docker restart 2>/dev/null || echo "Docker restart skipped (may need manual restart)"
            
            # Wait for Docker to fully restart and load configuration
            echo "Waiting for Docker daemon to fully restart and load configuration..."
            sleep 5
            
            # Verify Docker is running and configuration is loaded
            for i in {1..15}; do
              if docker info > /dev/null 2>&1; then
                echo "Docker is running (attempt $i)"
                # Give it a moment more to fully load configuration
                sleep 2
                break
              else
                echo "Waiting for Docker to start... ($i/15)"
                sleep 2
              fi
            done
            
            # Verify daemon.json is still correct after restart
            echo "Verifying daemon.json after restart:"
            sudo cat /etc/docker/daemon.json
            
            # Recreate buildx builder to pick up new daemon configuration
            echo "Recreating buildx builder to pick up daemon configuration..."
            docker buildx rm builder 2>/dev/null || true
            docker buildx create --name builder --use --driver docker-container --driver-opt network=host 2>/dev/null || \
            docker buildx create --name builder --use 2>/dev/null || \
            echo "Using default buildx builder"
            
            # Force Docker to reload configuration by sending SIGHUP (if supported)
            echo "Attempting to reload Docker configuration..."
            sudo killall -HUP dockerd 2>/dev/null || sudo pkill -HUP dockerd 2>/dev/null || echo "HUP signal not supported"
          else
            echo "Warning: Docker daemon configuration requires sudo. Registry may fail if not configured."
            echo "Please manually configure /etc/docker/daemon.json with:"
            echo '{'
            echo '  "insecure-registries": ["'$REGISTRY_HOST'"]'
            echo '}'
            exit 1
          fi

      - name: Log in to local registry
        run: |
          # Test registry connectivity via HTTP first
          echo "Testing registry connectivity via HTTP..."
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          curl -v --connect-timeout 5 ${REGISTRY_URL}/v2/ 2>&1 | head -10 || echo "Registry connectivity test"
          
          # Local registry may not require authentication
          # Note: docker login might still try HTTPS, but we'll test HTTP connectivity
          echo "Attempting Docker login (may fail if registry doesn't require auth)..."
          docker login ${{ env.REGISTRY_URL }} --username="" --password="" 2>&1 || \
          docker login ${{ env.REGISTRY_HOST }} --username="" --password="" 2>&1 || \
          echo "Registry login skipped (local registry may not require auth)"
        continue-on-error: true

      - name: Verify Docker registry configuration
        run: |
          echo "=== Verifying Docker daemon configuration ==="
          if [ -f /etc/docker/daemon.json ]; then
            echo "Docker daemon.json contents:"
            sudo cat /etc/docker/daemon.json
            echo ""
            echo "Checking if insecure-registries is configured..."
            if grep -q "insecure-registries" /etc/docker/daemon.json; then
              echo "âœ“ insecure-registries found in daemon.json"
              if grep -q "${{ env.REGISTRY_HOST }}" /etc/docker/daemon.json; then
                echo "âœ“ Registry ${{ env.REGISTRY_HOST }} found in insecure-registries"
              else
                echo "âœ— Registry ${{ env.REGISTRY_HOST }} NOT found in insecure-registries"
                exit 1
              fi
            else
              echo "âœ— insecure-registries NOT found in daemon.json"
              exit 1
            fi
          else
            echo "âœ— /etc/docker/daemon.json does not exist"
            exit 1
          fi
          
          # Verify Docker daemon is actually using the configuration
          echo ""
          echo "=== Docker daemon configuration ==="
          docker info 2>&1 | head -20
          
          # Test registry HTTP connectivity
          echo ""
          echo "=== Testing registry HTTP connectivity ==="
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          echo "Testing: ${REGISTRY_URL}/v2/"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 ${REGISTRY_URL}/v2/ 2>/dev/null || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "404" ]; then
            echo "âœ“ Registry is accessible via HTTP (HTTP code: $HTTP_CODE)"
          else
            echo "âš  Registry HTTP test returned code: $HTTP_CODE (may still work with Docker)"
          fi
          
          # Force Docker to reload configuration
          echo ""
          echo "=== Reloading Docker configuration ==="
          sudo killall -HUP dockerd 2>/dev/null || sudo pkill -HUP dockerd 2>/dev/null || echo "HUP signal not supported"
          sleep 2

      - name: Build and push Docker image
        run: |
          # Build and push to local HTTP registry
          # Strategy: Build with buildx, then push with docker push (which respects daemon.json insecure-registries)
          
          REGISTRY="${{ env.REGISTRY_HOST }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          SHA="${{ github.sha }}"
          
          # Build the image and load it into local Docker daemon
          # This ensures the image is available for docker push which respects insecure-registries
          echo "=== Building Docker image with buildx ==="
          docker buildx build \
            --platform linux/amd64 \
            --tag ${REGISTRY}/${IMAGE_NAME}:${SHA} \
            --tag ${REGISTRY}/${IMAGE_NAME}:latest \
            --load \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            .
          
          # Verify image was built
          echo ""
          echo "=== Verifying built images ==="
          docker images | grep "${IMAGE_NAME}" || exit 1
          
          # Double-check daemon.json before pushing
          echo ""
          echo "=== Final daemon.json check before push ==="
          sudo cat /etc/docker/daemon.json
          
          # Test registry connectivity first
          echo ""
          echo "=== Testing registry connectivity ==="
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          echo "Testing HTTP connection to ${REGISTRY_URL}..."
          curl -v --connect-timeout 5 ${REGISTRY_URL}/v2/ 2>&1 | head -20 || echo "Registry connectivity test completed"
          
          # Push using docker push (which respects daemon.json insecure-registries)
          echo ""
          echo "=== Pushing image to registry ==="
          echo "Using registry: ${REGISTRY}"
          echo "Image: ${REGISTRY}/${IMAGE_NAME}:${SHA}"
          
          # Set DOCKER_CONTENT_TRUST=0 to disable content trust
          export DOCKER_CONTENT_TRUST=0
          
          # Verify Docker daemon configuration one more time
          echo "Docker daemon insecure-registries:"
          docker info 2>/dev/null | grep -i "insecure" || echo "Could not verify insecure-registries in docker info"
          
          # Try pushing with explicit HTTP registry URL
          # Note: Docker image tags don't include protocol, but we can try to force HTTP
          # by ensuring the registry is in insecure-registries and Docker uses it
          echo ""
          echo "Attempting to push ${REGISTRY}/${IMAGE_NAME}:${SHA}..."
          
          # Use docker push with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker push ${REGISTRY}/${IMAGE_NAME}:${SHA} 2>&1; then
              echo "âœ“ Successfully pushed ${REGISTRY}/${IMAGE_NAME}:${SHA}"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 5
                # Try to reload Docker configuration
                sudo killall -HUP dockerd 2>/dev/null || true
                sleep 2
              else
                echo "âœ— Failed to push after $MAX_RETRIES attempts"
                echo "Trying alternative method: using docker save/load via HTTP..."
                
                # Alternative: Save image and push via HTTP API directly
                # This is a workaround if docker push doesn't work
                docker save ${REGISTRY}/${IMAGE_NAME}:${SHA} | gzip | \
                  curl -X POST --data-binary @- \
                  -H "Content-Type: application/vnd.docker.image.rootfs.diff.tar.gzip" \
                  ${REGISTRY_URL}/v2/${IMAGE_NAME}/blobs/uploads/ 2>&1 || \
                  echo "Alternative push method also failed"
                exit 1
              fi
            fi
          done
          
          echo "Pushing ${REGISTRY}/${IMAGE_NAME}:latest..."
          docker push ${REGISTRY}/${IMAGE_NAME}:latest 2>&1 || echo "Warning: Failed to push latest tag"
          
          echo ""
          echo "âœ“ Image push completed: ${REGISTRY}/${IMAGE_NAME}:${SHA}"
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_STEP_LOG_MAX_SIZE: 50000000
          BUILDKIT_STEP_LOG_MAX_SPEED: 100000000
          DOCKER_CONTENT_TRUST: 0

      - name: Set image tag
        id: image
        run: |
          # Use REGISTRY_HOST (without http://) for image tag
          IMAGE_TAG="${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Built and pushed: $IMAGE_TAG"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        id: kubeconfig
        run: |
          # For k3s self-hosted runner, kubeconfig is typically at /etc/rancher/k3s/k3s.yaml
          # If KUBECONFIG secret is provided, use it; otherwise use k3s default location
          KUBECONFIG_PATH=""
          if [ -n "${{ secrets.KUBECONFIG }}" ]; then
            mkdir -p ~/.kube
            echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
            chmod 600 ~/.kube/config
            KUBECONFIG_PATH=~/.kube/config
          elif [ -f /etc/rancher/k3s/k3s.yaml ]; then
            mkdir -p ~/.kube
            cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
            chmod 600 ~/.kube/config
            # Update server URL to use localhost for self-hosted runner
            sed -i 's/127.0.0.1/localhost/g' ~/.kube/config 2>/dev/null || sed -i '' 's/127.0.0.1/localhost/g' ~/.kube/config 2>/dev/null || true
            KUBECONFIG_PATH=~/.kube/config
          else
            echo "Error: No kubeconfig found. Please set KUBECONFIG secret or ensure k3s.yaml exists at /etc/rancher/k3s/k3s.yaml"
            exit 1
          fi
          echo "kubeconfig_path=$KUBECONFIG_PATH" >> $GITHUB_OUTPUT
          echo "KUBECONFIG_PATH=$KUBECONFIG_PATH" >> $GITHUB_ENV

      - name: Terraform Init
        working-directory: ./infra
        run: terraform init

      - name: Create Terraform variables file
        working-directory: ./infra
        run: |
          # Use empty map if secret_data is not provided
          SECRET_DATA="${{ secrets.TF_VAR_secret_data }}"
          if [ -z "$SECRET_DATA" ]; then
            SECRET_DATA="{}"
          fi
          cat > terraform.tfvars <<EOF
          kubeconfig_path = "${{ steps.kubeconfig.outputs.kubeconfig_path }}"
          project_name = "${{ secrets.TF_VAR_project_name }}"
          namespace = "${{ secrets.TF_VAR_namespace }}"
          domain = "${{ secrets.TF_VAR_domain }}"
          base_path = "${{ secrets.TF_VAR_base_path }}"
          image = "${{ steps.image.outputs.image_tag }}"
          replicas_web = ${{ secrets.TF_VAR_replicas_web }}
          resources_web = ${{ secrets.TF_VAR_resources_web }}
          secret_data = $SECRET_DATA
          EOF

      - name: Terraform Plan
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: terraform plan

      - name: Terraform Apply
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: terraform apply -auto-approve

      - name: Deployment Summary
        run: |
          echo "## Full Application Deployment Complete ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ steps.image.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed Resources:**" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: \`${{ secrets.TF_VAR_namespace }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment: \`${{ secrets.TF_VAR_project_name }}-web\`" >> $GITHUB_STEP_SUMMARY
          echo "- Service: \`${{ secrets.TF_VAR_project_name }}-web\`" >> $GITHUB_STEP_SUMMARY
          echo "- Ingress: \`${{ secrets.TF_VAR_project_name }}\`" >> $GITHUB_STEP_SUMMARY

