name: Build and Deploy Application

on:
  push:
    branches:
      - feat/infra

env:
  # Use host IP for registry (update REGISTRY_HOST_IP with your first server IP)
  # Or use a secret: ${{ secrets.REGISTRY_HOST_IP }}
  REGISTRY_HOST_IP: ${{ secrets.REGISTRY_HOST_IP || '192.168.1.100' }}  # Update with your first server IP
  REGISTRY_PORT: 5000
  REGISTRY_URL: http://${REGISTRY_HOST_IP}:${REGISTRY_PORT}
  REGISTRY_HOST: ${REGISTRY_HOST_IP}:${REGISTRY_PORT}
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-deploy:
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
          driver: docker
      
      - name: Verify buildx and architecture
        run: |
          echo "=== System Information ==="
          echo "Architecture: $(uname -m)"
          echo "OS: $(uname -a)"
          echo ""
          echo "=== Docker Information ==="
          docker version
          echo ""
          echo "=== Buildx Information ==="
          docker buildx version
          docker buildx ls
          echo ""
          echo "=== Buildx Builder Details ==="
          docker buildx inspect --bootstrap || echo "Builder inspection skipped"

      - name: Configure Docker for host registry
        run: |
          REGISTRY_HOST="${{ env.REGISTRY_HOST }}"
          
          # Configure insecure registry for HTTP access
          sudo mkdir -p /etc/docker
          
          if [ -f /etc/docker/daemon.json ]; then
            sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.bak 2>/dev/null || true
            
            if command -v jq &> /dev/null; then
              # Use jq to safely update daemon.json
              if ! jq -e '.insecure-registries' /etc/docker/daemon.json > /dev/null 2>&1; then
                jq '. + {"insecure-registries": ["'$REGISTRY_HOST'"]}' /etc/docker/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null
              elif ! jq -e '.insecure-registries[] | select(. == "'$REGISTRY_HOST'")' /etc/docker/daemon.json > /dev/null 2>&1; then
                jq '.insecure-registries += ["'$REGISTRY_HOST'"]' /etc/docker/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null
              fi
            else
              # Simple sed approach
              if ! grep -q "$REGISTRY_HOST" /etc/docker/daemon.json 2>/dev/null; then
                if ! grep -q "insecure-registries" /etc/docker/daemon.json; then
                  sudo sed -i 's/}/,\n  "insecure-registries": ["'$REGISTRY_HOST'"]\n}/' /etc/docker/daemon.json
                else
                  sudo sed -i 's/"insecure-registries": \[/"insecure-registries": ["'$REGISTRY_HOST'", /' /etc/docker/daemon.json
                fi
              fi
            fi
          else
            echo '{"insecure-registries": ["'$REGISTRY_HOST'"]}' | sudo tee /etc/docker/daemon.json > /dev/null
          fi
          
          echo "Docker daemon.json configured:"
          sudo cat /etc/docker/daemon.json
          
          # Restart Docker to apply configuration
          echo "Restarting Docker daemon..."
          sudo systemctl restart docker || sudo service docker restart || true
          sleep 5
          
          # Wait for Docker to be ready
          for i in {1..10}; do
            if docker info > /dev/null 2>&1; then
              echo "Docker is ready"
              break
            fi
            echo "Waiting for Docker... ($i/10)"
            sleep 2
          done

      - name: Log in to registry
        run: |
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          REGISTRY_USER="${{ secrets.REGISTRY_USERNAME || 'admin' }}"
          REGISTRY_PASS="${{ secrets.REGISTRY_PASSWORD }}"
          
          echo "Testing registry connectivity..."
          curl -f --connect-timeout 5 ${REGISTRY_URL}/v2/ 2>&1 | head -5 || echo "Registry connectivity check"
          
          echo "Logging in to registry..."
          echo "$REGISTRY_PASS" | docker login ${REGISTRY_URL} -u "$REGISTRY_USER" --password-stdin || {
            echo "Warning: Registry login failed (may not require auth)"
          }
        continue-on-error: true

      - name: Build and push Docker image
        run: |
          REGISTRY="${{ env.REGISTRY_HOST }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          SHA="${{ github.sha }}"
          
          # Detect runner architecture
          ARCH=$(uname -m)
          case $ARCH in
            x86_64)
              PLATFORM="linux/amd64"
              ;;
            aarch64|arm64)
              PLATFORM="linux/arm64"
              ;;
            *)
              echo "Warning: Unknown architecture $ARCH, defaulting to linux/amd64"
              PLATFORM="linux/amd64"
              ;;
          esac
          
          echo "=== Building Docker image ==="
          echo "Detected architecture: $ARCH"
          echo "Using platform: $PLATFORM"
          
          docker buildx build \
            --platform $PLATFORM \
            --tag ${REGISTRY}/${IMAGE_NAME}:${SHA} \
            --tag ${REGISTRY}/${IMAGE_NAME}:latest \
            --load \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            .
          
          echo "=== Verifying built images ==="
          docker images | grep "${IMAGE_NAME}" || exit 1
          
          echo "=== Pushing image to registry ==="
          echo "Registry: ${REGISTRY}"
          echo "Image: ${REGISTRY}/${IMAGE_NAME}:${SHA}"
          
          # Push with HTTP (insecure-registries handles this)
          docker push ${REGISTRY}/${IMAGE_NAME}:${SHA} || exit 1
          docker push ${REGISTRY}/${IMAGE_NAME}:latest || echo "Warning: Failed to push latest tag"
          
          echo "âœ“ Successfully pushed: ${REGISTRY}/${IMAGE_NAME}:${SHA}"
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_STEP_LOG_MAX_SIZE: 50000000
          BUILDKIT_STEP_LOG_MAX_SPEED: 100000000
          DOCKER_CONTENT_TRUST: 0

      - name: Set image tag
        id: image
        run: |
          IMAGE_TAG="${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Built and pushed: $IMAGE_TAG"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        id: kubeconfig
        run: |
          KUBECONFIG_PATH=""
          if [ -n "${{ secrets.KUBECONFIG }}" ]; then
            mkdir -p ~/.kube
            echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
            chmod 600 ~/.kube/config
            KUBECONFIG_PATH=~/.kube/config
          elif [ -f /etc/rancher/k3s/k3s.yaml ]; then
            mkdir -p ~/.kube
            cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
            chmod 600 ~/.kube/config
            sed -i 's/127.0.0.1/localhost/g' ~/.kube/config 2>/dev/null || sed -i '' 's/127.0.0.1/localhost/g' ~/.kube/config 2>/dev/null || true
            KUBECONFIG_PATH=~/.kube/config
          else
            echo "Error: No kubeconfig found"
            exit 1
          fi
          echo "kubeconfig_path=$KUBECONFIG_PATH" >> $GITHUB_OUTPUT
          echo "KUBECONFIG_PATH=$KUBECONFIG_PATH" >> $GITHUB_ENV

      - name: Terraform Init
        working-directory: ./infra
        run: terraform init

      - name: Create Terraform variables file
        working-directory: ./infra
        run: |
          SECRET_DATA="${{ secrets.TF_VAR_secret_data }}"
          if [ -z "$SECRET_DATA" ]; then
            SECRET_DATA="{}"
          fi
          cat > terraform.tfvars <<EOF
          kubeconfig_path = "${{ steps.kubeconfig.outputs.kubeconfig_path }}"
          project_name = "${{ secrets.TF_VAR_project_name }}"
          namespace = "${{ secrets.TF_VAR_namespace }}"
          domain = "${{ secrets.TF_VAR_domain }}"
          base_path = "${{ secrets.TF_VAR_base_path }}"
          image = "${{ steps.image.outputs.image_tag }}"
          replicas_web = ${{ secrets.TF_VAR_replicas_web }}
          resources_web = ${{ secrets.TF_VAR_resources_web }}
          secret_data = $SECRET_DATA
          EOF

      - name: Terraform Plan
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: terraform plan

      - name: Terraform Apply
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: terraform apply -auto-approve

      - name: Deployment Summary
        run: |
          echo "## Full Application Deployment Complete ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ steps.image.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed Resources:**" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: \`${{ secrets.TF_VAR_namespace }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment: \`${{ secrets.TF_VAR_project_name }}-web\`" >> $GITHUB_STEP_SUMMARY
          echo "- Service: \`${{ secrets.TF_VAR_project_name }}-web\`" >> $GITHUB_STEP_SUMMARY
          echo "- Ingress: \`${{ secrets.TF_VAR_project_name }}\`" >> $GITHUB_STEP_SUMMARY