name: Build and Deploy Application
# Triggered on push to main or feat/infra branches

on:
  push:
    branches:
      - main
      - feat/infra

env:
  # Registry Configuration:
  # REGISTRY_HOST_IP can be set as:
  # 1. Environment secret (recommended): Settings > Environments > production > Secrets
  # 2. Repository secret: Settings > Secrets and variables > Actions
  # Environment secrets take precedence over repository secrets
  # 
  # If not set, defaults to 192.168.1.100 (update this if needed)
  REGISTRY_HOST_IP: ${{ secrets.REGISTRY_HOST_IP || '192.168.1.100' }}
  REGISTRY_PORT: 5000
  REGISTRY_URL: http://${REGISTRY_HOST_IP}:${REGISTRY_PORT}
  REGISTRY_HOST: ${REGISTRY_HOST_IP}:${REGISTRY_PORT}
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-deploy:
    runs-on: self-hosted
    # Use production environment for main and feat/infra branches
    environment: 
      name: production
      url: ${{ steps.deployment.outputs.url || '' }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Display deployment info
        run: |
          echo "=== Deployment Information ==="
          echo "Environment: production"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Repository: ${{ github.repository }}"
          echo ""
          echo "Note: Environment secrets and variables can be configured at:"
          echo "Settings > Environments > production"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
          driver: docker
      
      - name: Verify buildx and architecture
        run: |
          echo "=== System Information ==="
          echo "Architecture: $(uname -m)"
          echo "OS: $(uname -a)"
          echo ""
          echo "=== Docker Information ==="
          docker version
          echo ""
          echo "=== Buildx Information ==="
          docker buildx version
          docker buildx ls
          echo ""
          echo "=== Buildx Builder Details ==="
          docker buildx inspect --bootstrap || echo "Builder inspection skipped"

      - name: Configure Docker for host registry
        run: |
          REGISTRY_HOST="${{ env.REGISTRY_HOST }}"
          
          # Configure insecure registry for HTTP access
          sudo mkdir -p /etc/docker
          
          if [ -f /etc/docker/daemon.json ]; then
            sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.bak 2>/dev/null || true
            
            if command -v jq &> /dev/null; then
              # Use jq to safely update daemon.json
              if ! jq -e '.insecure-registries' /etc/docker/daemon.json > /dev/null 2>&1; then
                jq '. + {"insecure-registries": ["'$REGISTRY_HOST'"]}' /etc/docker/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null
              elif ! jq -e '.insecure-registries[] | select(. == "'$REGISTRY_HOST'")' /etc/docker/daemon.json > /dev/null 2>&1; then
                jq '.insecure-registries += ["'$REGISTRY_HOST'"]' /etc/docker/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null
              fi
            else
              # Simple sed approach
              if ! grep -q "$REGISTRY_HOST" /etc/docker/daemon.json 2>/dev/null; then
                if ! grep -q "insecure-registries" /etc/docker/daemon.json; then
                  sudo sed -i 's/}/,\n  "insecure-registries": ["'$REGISTRY_HOST'"]\n}/' /etc/docker/daemon.json
                else
                  sudo sed -i 's/"insecure-registries": \[/"insecure-registries": ["'$REGISTRY_HOST'", /' /etc/docker/daemon.json
                fi
              fi
            fi
          else
            echo '{"insecure-registries": ["'$REGISTRY_HOST'"]}' | sudo tee /etc/docker/daemon.json > /dev/null
          fi
          
          echo "Docker daemon.json configured:"
          sudo cat /etc/docker/daemon.json
          
          # Restart Docker to apply configuration
          echo "Restarting Docker daemon..."
          # Stop Docker first to ensure clean restart
          sudo systemctl stop docker 2>/dev/null || sudo service docker stop 2>/dev/null || true
          sleep 2
          # Start Docker
          sudo systemctl start docker 2>/dev/null || sudo service docker start 2>/dev/null || true
          # Also try full restart as fallback
          sudo systemctl restart docker 2>/dev/null || sudo service docker restart 2>/dev/null || true
          sleep 5
          
          # Wait for Docker to be ready
          for i in {1..15}; do
            if docker info > /dev/null 2>&1; then
              echo "Docker is ready"
              # Verify configuration is loaded (Docker info may not show insecure-registries, but that's OK)
              echo "Docker version: $(docker version --format '{{.Server.Version}}' 2>/dev/null || echo 'unknown')"
              break
            fi
            echo "Waiting for Docker... ($i/15)"
            sleep 2
          done
          
          # Verify daemon.json is still correct
          echo ""
          echo "Verifying daemon.json after restart:"
          sudo cat /etc/docker/daemon.json

      - name: Verify registry connectivity and Docker config
        run: |
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          REGISTRY_HOST="${{ env.REGISTRY_HOST }}"
          
          echo "=== Registry Configuration ==="
          echo "REGISTRY_HOST_IP: ${{ env.REGISTRY_HOST_IP }}"
          echo "REGISTRY_URL: ${REGISTRY_URL}"
          echo "REGISTRY_HOST: ${REGISTRY_HOST}"
          echo ""
          
          echo "=== Verifying Docker daemon.json ==="
          if [ -f /etc/docker/daemon.json ]; then
            echo "Current daemon.json:"
            sudo cat /etc/docker/daemon.json
            if grep -q "$REGISTRY_HOST" /etc/docker/daemon.json; then
              echo "âœ“ Registry ${REGISTRY_HOST} found in insecure-registries"
            else
              echo "âœ— WARNING: Registry ${REGISTRY_HOST} NOT found in insecure-registries"
            fi
          else
            echo "âœ— WARNING: /etc/docker/daemon.json does not exist"
          fi
          echo ""
          
          echo "=== Testing registry HTTP connectivity ==="
          echo "Testing: ${REGISTRY_URL}/v2/"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 ${REGISTRY_URL}/v2/ 2>/dev/null || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "404" ]; then
            echo "âœ“ Registry is accessible via HTTP (HTTP code: $HTTP_CODE)"
          elif [ "$HTTP_CODE" = "000" ]; then
            echo "âœ— ERROR: Cannot connect to registry at ${REGISTRY_URL}"
            echo "  - Check if REGISTRY_HOST_IP is correct"
            echo "  - Check if registry is running and accessible from runner"
            echo "  - Check network connectivity: ping ${{ env.REGISTRY_HOST_IP }}"
            exit 1
          else
            echo "âš  Registry returned HTTP code: $HTTP_CODE (may still work)"
          fi

      - name: Log in to registry
        run: |
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          REGISTRY_USER="${{ secrets.REGISTRY_USERNAME || 'admin' }}"
          REGISTRY_PASS="${{ secrets.REGISTRY_PASSWORD }}"
          
          echo "Logging in to registry..."
          echo "$REGISTRY_PASS" | docker login ${REGISTRY_URL} -u "$REGISTRY_USER" --password-stdin || {
            echo "Warning: Registry login failed (may not require auth)"
          }
        continue-on-error: true

      - name: Build and push Docker image
        run: |
          REGISTRY="${{ env.REGISTRY_HOST }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          SHA="${{ github.sha }}"
          
          # Detect runner architecture
          ARCH=$(uname -m)
          case $ARCH in
            x86_64)
              PLATFORM="linux/amd64"
              ;;
            aarch64|arm64)
              PLATFORM="linux/arm64"
              ;;
            *)
              echo "Warning: Unknown architecture $ARCH, defaulting to linux/amd64"
              PLATFORM="linux/amd64"
              ;;
          esac
          
          echo "=== Building Docker image ==="
          echo "Detected architecture: $ARCH"
          echo "Using platform: $PLATFORM"
          
          docker buildx build \
            --platform $PLATFORM \
            --tag ${REGISTRY}/${IMAGE_NAME}:${SHA} \
            --tag ${REGISTRY}/${IMAGE_NAME}:latest \
            --load \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            .
          
          echo "=== Verifying built images ==="
          docker images | grep "${IMAGE_NAME}" || exit 1
          
          echo ""
          echo "=== Final verification before push ==="
          echo "Verifying Docker daemon.json configuration..."
          if [ -f /etc/docker/daemon.json ]; then
            if grep -q "${REGISTRY}" /etc/docker/daemon.json; then
              echo "âœ“ Registry ${REGISTRY} is configured in insecure-registries"
            else
              echo "âœ— ERROR: Registry ${REGISTRY} NOT in insecure-registries"
              echo "Current daemon.json:"
              sudo cat /etc/docker/daemon.json
              exit 1
            fi
          else
            echo "âœ— ERROR: /etc/docker/daemon.json does not exist"
            exit 1
          fi
          
          echo ""
          echo "=== Pushing image to registry ==="
          echo "Registry: ${REGISTRY}"
          echo "Image: ${REGISTRY}/${IMAGE_NAME}:${SHA}"
          echo "Note: Docker should use HTTP (configured via insecure-registries)"
          
          # Try docker push first
          if docker push ${REGISTRY}/${IMAGE_NAME}:${SHA} 2>&1 | tee /tmp/push.log; then
            echo "âœ“ Successfully pushed ${REGISTRY}/${IMAGE_NAME}:${SHA}"
          else
            # Check if error is HTTPS-related
            if grep -q "HTTPS\|TLS\|certificate\|http: server gave HTTP response to HTTPS" /tmp/push.log; then
              echo ""
              echo "âœ— Docker push failed with HTTPS error despite insecure-registries"
              echo "Attempting workaround: forcing Docker to reload configuration..."
              
              # Force Docker to reload configuration
              sudo killall -HUP dockerd 2>/dev/null || true
              sleep 3
              
              # Try one more time after reload
              if docker push ${REGISTRY}/${IMAGE_NAME}:${SHA} 2>&1; then
                echo "âœ“ Successfully pushed after config reload"
              else
                echo ""
                echo "âœ— Docker push still failing. Docker may not support HTTP registries properly."
                echo "Please ensure:"
                echo "  1. Docker daemon is restarted after daemon.json changes"
                echo "  2. Registry ${REGISTRY} is accessible via HTTP"
                echo "  3. Consider using a registry that supports HTTPS or configure proper certificates"
                exit 1
              fi
            else
              echo "âœ— Docker push failed with non-HTTPS error"
              exit 1
            fi
          fi
          
          # Push latest tag
          docker push ${REGISTRY}/${IMAGE_NAME}:latest || echo "Warning: Failed to push latest tag"
          
          echo "âœ“ Successfully pushed: ${REGISTRY}/${IMAGE_NAME}:${SHA}"
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_STEP_LOG_MAX_SIZE: 50000000
          BUILDKIT_STEP_LOG_MAX_SPEED: 100000000
          DOCKER_CONTENT_TRUST: 0

      - name: Set image tag
        id: image
        run: |
          IMAGE_TAG="${{ env.REGISTRY_HOST }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Built and pushed: $IMAGE_TAG"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          check-latest: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Configure kubectl
        id: kubeconfig
        run: |
          echo "=== Searching for kubeconfig ==="
          KUBECONFIG_PATH=""
          
          # Method 1: Use KUBECONFIG secret if provided
          if [ -n "${{ secrets.KUBECONFIG }}" ]; then
            echo "Found KUBECONFIG secret, using it..."
            mkdir -p ~/.kube
            echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
            chmod 600 ~/.kube/config
            KUBECONFIG_PATH=~/.kube/config
            echo "âœ“ Using kubeconfig from KUBECONFIG secret"
          
          # Method 2: Check common k3s locations
          elif [ -f /etc/rancher/k3s/k3s.yaml ]; then
            echo "Found k3s.yaml at /etc/rancher/k3s/k3s.yaml"
            mkdir -p ~/.kube
            cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
            chmod 600 ~/.kube/config
            # Update server URL for self-hosted runner
            sed -i 's/127.0.0.1/localhost/g' ~/.kube/config 2>/dev/null || sed -i '' 's/127.0.0.1/localhost/g' ~/.kube/config 2>/dev/null || true
            KUBECONFIG_PATH=~/.kube/config
            echo "âœ“ Using kubeconfig from /etc/rancher/k3s/k3s.yaml"
          
          # Method 3: Check if ~/.kube/config already exists
          elif [ -f ~/.kube/config ]; then
            echo "Found existing ~/.kube/config"
            KUBECONFIG_PATH=~/.kube/config
            echo "âœ“ Using existing ~/.kube/config"
          
          # Method 4: Check KUBECONFIG environment variable
          elif [ -n "$KUBECONFIG" ] && [ -f "$KUBECONFIG" ]; then
            echo "Found kubeconfig from KUBECONFIG environment variable: $KUBECONFIG"
            KUBECONFIG_PATH="$KUBECONFIG"
            echo "âœ“ Using kubeconfig from KUBECONFIG env var"
          
          # Method 5: Try to find k3s config in alternative locations
          else
            echo "Searching for k3s config in alternative locations..."
            for path in "/root/.kube/config" "/home/runner/.kube/config" "/var/lib/rancher/k3s/agent/kubeconfig.yaml"; do
              if [ -f "$path" ]; then
                echo "Found kubeconfig at: $path"
                mkdir -p ~/.kube
                cp "$path" ~/.kube/config
                chmod 600 ~/.kube/config
                KUBECONFIG_PATH=~/.kube/config
                echo "âœ“ Using kubeconfig from $path"
                break
              fi
            done
          fi
          
          # Verify kubeconfig is valid
          if [ -n "$KUBECONFIG_PATH" ] && [ -f "$KUBECONFIG_PATH" ]; then
            echo ""
            echo "=== Verifying kubeconfig ==="
            export KUBECONFIG="$KUBECONFIG_PATH"
            if kubectl cluster-info &>/dev/null; then
              echo "âœ“ kubeconfig is valid and can connect to cluster"
              kubectl cluster-info | head -1
            else
              echo "âš  Warning: kubeconfig found but cannot connect to cluster"
              echo "This may be OK if cluster is not accessible from runner"
            fi
          else
            echo ""
            echo "âœ— ERROR: No kubeconfig found"
            echo ""
            echo "Please configure kubeconfig using one of these methods:"
            echo "1. Set KUBECONFIG secret in GitHub (Settings > Secrets > Actions)"
            echo "   - Base64 encode your kubeconfig: cat ~/.kube/config | base64"
            echo "   - Add as secret named 'KUBECONFIG'"
            echo ""
            echo "2. Ensure k3s.yaml exists at: /etc/rancher/k3s/k3s.yaml"
            echo "   - For k3s: sudo cat /etc/rancher/k3s/k3s.yaml"
            echo ""
            echo "3. Place kubeconfig at: ~/.kube/config on the runner"
            echo ""
            echo "Checked locations:"
            echo "  - /etc/rancher/k3s/k3s.yaml"
            echo "  - ~/.kube/config"
            echo "  - /root/.kube/config"
            echo "  - /home/runner/.kube/config"
            echo "  - /var/lib/rancher/k3s/agent/kubeconfig.yaml"
            exit 1
          fi
          
          echo ""
          echo "=== kubeconfig Configuration ==="
          echo "KUBECONFIG_PATH: $KUBECONFIG_PATH"
          echo "kubeconfig_path=$KUBECONFIG_PATH" >> $GITHUB_OUTPUT
          echo "KUBECONFIG_PATH=$KUBECONFIG_PATH" >> $GITHUB_ENV
          export KUBECONFIG="$KUBECONFIG_PATH"

      # ==========================================
      # Infrastructure Deployment Phase
      # ==========================================
      
      - name: Prepare Infrastructure Configuration
        id: prepare-infra
        working-directory: ./infra
        run: |
          echo "=== Preparing Infrastructure Configuration ==="
          
          # Extract project name from repository (fallback to default)
          REPO_NAME="${{ github.repository }}"
          DEFAULT_PROJECT_NAME="${REPO_NAME#*/}"  # Extract name after owner/
          
          # Use secrets or defaults
          PROJECT_NAME="${{ secrets.TF_VAR_project_name }}"
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="$DEFAULT_PROJECT_NAME"
            echo "âš  Warning: TF_VAR_project_name not set, using default: $PROJECT_NAME"
          fi
          
          NAMESPACE="${{ secrets.TF_VAR_namespace }}"
          if [ -z "$NAMESPACE" ]; then
            NAMESPACE="$PROJECT_NAME"
            echo "âš  Warning: TF_VAR_namespace not set, using default: $NAMESPACE"
          fi
          
          DOMAIN="${{ secrets.TF_VAR_domain }}"
          if [ -z "$DOMAIN" ]; then
            echo "âœ— Error: TF_VAR_domain secret is required"
            echo ""
            echo "Please set the following GitHub Secrets:"
            echo "  - TF_VAR_domain: Your domain (e.g., ni2faa.ddns.net)"
            echo ""
            echo "Optional but recommended:"
            echo "  - TF_VAR_project_name: $PROJECT_NAME (currently using default)"
            echo "  - TF_VAR_namespace: $NAMESPACE (currently using default)"
            echo ""
            echo "See .github/SECRETS.md for full documentation"
            echo "Or run: .github/scripts/setup-secrets.sh"
            exit 1
          fi
          
          BASE_PATH="${{ secrets.TF_VAR_base_path }}"
          if [ -z "$BASE_PATH" ]; then
            BASE_PATH="/"
            echo "âš  Warning: TF_VAR_base_path not set, using default: $BASE_PATH"
          fi
          
          # Set defaults for optional values
          REPLICAS_WEB="${{ secrets.TF_VAR_replicas_web }}"
          if [ -z "$REPLICAS_WEB" ]; then
            REPLICAS_WEB="1"
            echo "âš  Warning: TF_VAR_replicas_web not set, using default: 1"
          fi
          
          RESOURCES_WEB="${{ secrets.TF_VAR_resources_web }}"
          if [ -z "$RESOURCES_WEB" ]; then
            echo "âš  Warning: TF_VAR_resources_web not set, using defaults"
          fi
          
          SECRET_DATA="${{ secrets.TF_VAR_secret_data }}"
          if [ -z "$SECRET_DATA" ]; then
            SECRET_DATA="{}"
          fi
          
          # Create terraform.tfvars file - NO HEREDOCS, pure echo
          echo 'kubeconfig_path = "'"${{ steps.kubeconfig.outputs.kubeconfig_path }}"'"' > terraform.tfvars
          echo 'project_name = "'"${PROJECT_NAME}"'"' >> terraform.tfvars
          echo 'namespace = "'"${NAMESPACE}"'"' >> terraform.tfvars
          echo 'domain = "'"${DOMAIN}"'"' >> terraform.tfvars
          echo 'base_path = "'"${BASE_PATH}"'"' >> terraform.tfvars
          echo 'image = "'"${{ steps.image.outputs.image_tag }}"'"' >> terraform.tfvars
          echo 'replicas_web = '"${REPLICAS_WEB}" >> terraform.tfvars
          echo 'resources_web = {' >> terraform.tfvars
          echo '  limits_cpu    = "1000m"' >> terraform.tfvars
          echo '  limits_memory = "1Gi"' >> terraform.tfvars
          echo '  requests_cpu    = "200m"' >> terraform.tfvars
          echo '  requests_memory = "256Mi"' >> terraform.tfvars
          echo '}' >> terraform.tfvars
          echo 'secret_data = '"${SECRET_DATA}" >> terraform.tfvars
          
          # Handle custom resources_web if provided
          if [ -n "$RESOURCES_WEB" ]; then
            # Remove default resources_web block and replace
            sed -i '/resources_web = {/,/^}/d' terraform.tfvars
            sed -i "/replicas_web/a resources_web = ${RESOURCES_WEB}" terraform.tfvars
          fi
          
          echo ""
          echo "âœ“ Terraform variables file created"
          echo ""
          echo "=== Configuration Summary ==="
          echo "  Project: ${PROJECT_NAME}"
          echo "  Namespace: ${NAMESPACE}"
          echo "  Domain: ${DOMAIN}"
          echo "  Base Path: ${BASE_PATH}"
          echo "  Image: ${{ steps.image.outputs.image_tag }}"
          echo "  Replicas: ${REPLICAS_WEB}"
          if [ -z "$RESOURCES_WEB" ]; then
            echo "  Resources: (using defaults)"
          else
            echo "  Resources: (custom)"
          fi
          echo ""
          echo "=== Generated terraform.tfvars ==="
          cat terraform.tfvars
          echo ""

      - name: Validate Terraform Variables File
        working-directory: ./infra
        run: |
          echo "=== Validating terraform.tfvars Syntax ==="
          if [ ! -f terraform.tfvars ]; then
            echo "âœ— Error: terraform.tfvars file not found"
            exit 1
          fi
          
          # Check for empty values that would cause syntax errors
          if grep -q "replicas_web = $" terraform.tfvars || grep -q "replicas_web =[[:space:]]*$" terraform.tfvars; then
            echo "âœ— Error: replicas_web has no value"
            exit 1
          fi
          
          if grep -q "resources_web = $" terraform.tfvars || grep -q "resources_web =[[:space:]]*$" terraform.tfvars; then
            echo "âœ— Error: resources_web has no value"
            exit 1
          fi
          
          echo "âœ“ terraform.tfvars syntax validation passed"

      - name: Initialize Terraform
        working-directory: ./infra
        run: |
          echo "=== Initializing Terraform ==="
          terraform init -upgrade
          echo "âœ“ Terraform initialized successfully"

      - name: Validate Infrastructure Configuration
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: |
          echo "=== Validating Infrastructure Configuration ==="
          terraform validate
          echo "âœ“ Terraform configuration is valid"

      - name: Plan Infrastructure Changes
        id: terraform-plan
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: |
          echo "=== Planning Infrastructure Changes ==="
          terraform plan -out=tfplan -detailed-exitcode
          PLAN_EXIT_CODE=$?
          
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "âœ“ No changes needed - infrastructure is up to date"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "âœ“ Changes detected - will apply in next step"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "âœ— Terraform plan failed"
            exit 1
          fi

      - name: Apply Infrastructure Changes
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: |
          echo "=== Applying Infrastructure Changes ==="
          if [ "${{ steps.terraform-plan.outputs.has_changes }}" = "true" ]; then
            terraform apply -auto-approve tfplan
            echo "âœ“ Infrastructure changes applied successfully"
          else
            echo "â„¹ No changes to apply - infrastructure is already up to date"
          fi

      - name: Verify Infrastructure Deployment
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: |
          echo "=== Verifying Infrastructure Deployment ==="
          # Read values from terraform.tfvars
          NAMESPACE=$(grep "^namespace" terraform.tfvars | cut -d'"' -f2)
          PROJECT_NAME=$(grep "^project_name" terraform.tfvars | cut -d'"' -f2)
          
          echo "Checking namespace..."
          kubectl get namespace "$NAMESPACE" || {
            echo "âœ— Namespace $NAMESPACE not found"
            exit 1
          }
          echo "âœ“ Namespace $NAMESPACE exists"
          
          echo ""
          echo "Checking deployment..."
          kubectl get deployment "${PROJECT_NAME}-web" -n "$NAMESPACE" || {
            echo "âœ— Deployment ${PROJECT_NAME}-web not found"
            exit 1
          }
          echo "âœ“ Deployment ${PROJECT_NAME}-web exists"
          
          echo ""
          echo "Checking deployment status..."
          kubectl rollout status deployment/"${PROJECT_NAME}-web" -n "$NAMESPACE" --timeout=5m || {
            echo "âš  Deployment rollout not complete, but continuing..."
          }
          
          echo ""
          echo "Checking pods..."
          kubectl get pods -n "$NAMESPACE" -l app="${PROJECT_NAME}-web"
          
          echo ""
          echo "Checking service..."
          kubectl get service "${PROJECT_NAME}-web" -n "$NAMESPACE" || {
            echo "âœ— Service ${PROJECT_NAME}-web not found"
            exit 1
          }
          echo "âœ“ Service ${PROJECT_NAME}-web exists"
          
          echo ""
          echo "Checking ingress..."
          kubectl get ingress -n "$NAMESPACE" | grep "$PROJECT_NAME" || {
            echo "âš  Ingress not found (may be expected)"
          }
          
          echo ""
          echo "âœ“ Infrastructure deployment verified"

      - name: Health Check Application
        working-directory: ./infra
        env:
          KUBECONFIG: ${{ steps.kubeconfig.outputs.kubeconfig_path }}
        run: |
          echo "=== Performing Application Health Check ==="
          # Read values from terraform.tfvars
          NAMESPACE=$(grep "^namespace" terraform.tfvars | cut -d'"' -f2)
          PROJECT_NAME=$(grep "^project_name" terraform.tfvars | cut -d'"' -f2)
          
          # Wait for pods to be ready
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app="${PROJECT_NAME}-web" \
            -n "$NAMESPACE" \
            --timeout=5m || {
            echo "âš  Some pods may not be ready yet"
          }
          
          # Get pod status
          echo ""
          echo "Pod status:"
          kubectl get pods -n "$NAMESPACE" -l app="${PROJECT_NAME}-web" -o wide
          
          # Check pod logs for errors
          echo ""
          echo "Recent pod logs (last 20 lines):"
          POD_NAME=$(kubectl get pods -n "$NAMESPACE" -l app="${PROJECT_NAME}-web" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ]; then
            kubectl logs "$POD_NAME" -n "$NAMESPACE" --tail=20 || echo "Could not retrieve logs"
          fi
          
          echo ""
          echo "âœ“ Health check completed"

      - name: Set deployment URL
        id: deployment
        working-directory: ./infra
        run: |
          # Construct deployment URL from domain
          DOMAIN=$(grep "^domain" terraform.tfvars | cut -d'"' -f2)
          BASE_PATH=$(grep "^base_path" terraform.tfvars | cut -d'"' -f2)
          if [ "$BASE_PATH" = "/" ]; then
            DEPLOYMENT_URL="https://${DOMAIN}"
          else
            DEPLOYMENT_URL="https://${DOMAIN}${BASE_PATH}"
          fi
          echo "url=${DEPLOYMENT_URL}" >> $GITHUB_OUTPUT
          echo "Deployment URL: ${DEPLOYMENT_URL}"

      - name: Deployment Summary
        run: |
          echo "## Full Application Deployment Complete ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`production\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ steps.image.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment URL:** ${{ steps.deployment.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed Resources:**" >> $GITHUB_STEP_SUMMARY
          cd ./infra
          NAMESPACE=$(grep "^namespace" terraform.tfvars | cut -d'"' -f2)
          PROJECT_NAME=$(grep "^project_name" terraform.tfvars | cut -d'"' -f2)
          echo "- Namespace: \`${NAMESPACE}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment: \`${PROJECT_NAME}-web\`" >> $GITHUB_STEP_SUMMARY
          echo "- Service: \`${PROJECT_NAME}-web\`" >> $GITHUB_STEP_SUMMARY
          echo "- Ingress: \`${PROJECT_NAME}\`" >> $GITHUB_STEP_SUMMARY